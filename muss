#!/bin/sh
## muss command-line music player interface
# Dan Brown, 2010
# 
# note: interactive mode depends on dmenu with
#       patches for xmms style multiple search
#       and filtermode multiple output.

HELP_MESSAGE="muss version 0.1
usage:   \"muss [options] [[not] <keyword>]...\" 
example: \"muss elvis\"
         \"muss elv pres not jailhouse\"
         \"muss lion rich -a -r\"
         \"muss\" (opens an interactive search menu)
         \"muss -p -l\"
         \"muss -n\"
options:
 -h help (also recognizes -? --help)
 -a append to (don't clear) existing playlist
 -q quiet. disables autoplay for the new playlist
 -r randomize playlist order for the new playlist
 -l list items in current playlist (don't browse)
 -p play/pause current playlist (don't browse)
 -s stop current playlist (don't browse)
 -n next song in current playlist (don't browse)
 -b back to previous song in current playlist (don't browse)
 -u update music database (don't browse)
"

DEBUG=0
PLMARKER="__playlist__ " 

print_debug() {
  # requires 2 arguments: MIN_LEVEL, VARIABLE_NAME
  # NOTE: the \$$ ref/deref requires #!/bin/bash, not #!/bin/sh
  if [ $DEBUG -ge $1 ] 
  then
    echo -n "$2: "; eval echo -n \$$2; echo " ."
  fi
}

PROG_ARGS=" $* "
option_check() {
  # look to see if the user included the option flag in the command
  # requires one argument, the flag. eg "-a"
  echo "$PROG_ARGS" | grep -i -E " $1 " > /dev/null
}

# print help message and usage, then exit
echo " $* " | grep -i -E '[ \t]\-{1,2}(help|h|\?)[ \t]' > /dev/null && \
  echo "$HELP_MESSAGE" && exit

if [ -f $HOME/.dmenurc ]
then
  . $HOME/.dmenurc
else
  DMENU='dmenu'
fi
DMENU="$DMENU -i -l 10 -f -xs"

# parse arguments for recognized options
# all non-help (non-early-termination) arguments should be listed below
IGNOREARGS='-a -q -r -l -p -s -n -b -u'
NOBROWSEARGS='-l -p -s -n -b -u'
IGNOREFILTER=" "`echo "$IGNOREARGS" | sed -e 's/ -/ \\\\| -/g'`" "
NOBROWSEFILTER=" "`echo "$NOBROWSEARGS" | sed -e 's/ -/ \\\\| -/g'`" "
SEARCHTERMS=`echo " $* " | sed \
  -e 's/ /  /g' \
  -e "s/$IGNOREFILTER/ /Ig"`
print_debug 1 SEARCHTERMS

collect_items() {
  PLAYLISTS=`mpc lsplaylists | sed -e "s/.*/$PLMARKER&/"`
  print_debug 2 PLAYLISTS
  FILES=`mpc listall`
  print_debug 2 FILES
}

if [ `echo $SEARCHTERMS | wc -w` -gt 0 ]
then
  # quicksearch mode
  # use the command line parameters as search terms
  # matching is done by (full) filepath
  # supports the "not" keyword to exclude patterns
  CRITERIA=`echo $SEARCHTERMS | sed \
    -e 's/not \(\S\)/__-v__\1/Ig' \
    -e 's/\S*/| grep -i \"&\"/g' \
    -e 's/\"__-v__/-v \"/g' \
    -e 's/ \"-/ \"\\\\-/g'`
  print_debug 2 CRITERIA
  collect_items
  ALLMATCHES=`eval "echo \"$FILES\\n$PLAYLISTS\" $CRITERIA"`
elif [ `echo " $* " | grep -i "$NOBROWSEFILTER" | wc -l` -gt 0  ]
then
  # we won't look for music to add.
  # we are probably just adjusting mpc state
  ALLMATCHES=""
else
  # interactive browse/search mode
  collect_items
  ALLMATCHES=`echo "$FILES\\n$PLAYLISTS" | $DMENU`
fi
print_debug 2 ALLMATCHES

LOADCOMMANDS=`echo "$ALLMATCHES" | sed \
  -e '/^$/d' \
  -e 's/.*/mpc add \"&\" > \/dev\/null;/g' \
  -e "s/mpc add \"$PLMARKER/mpc load \"/g"`
print_debug 1 LOADCOMMANDS

# check to see if we found some music to load
if [ `echo "$LOADCOMMANDS" | wc -c` -ge 5 ]
then
  # check for append mode
  option_check -a || mpc clear > /dev/null
  eval "$LOADCOMMANDS > /dev/null"
  # we need to randomize before autoplay begins
  option_check -r && mpc shuffle > /dev/null
  # start autoplay
  option_check -q || mpc play > /dev/null
fi

# note: we may randomize twice. oh well
option_check -r && mpc shuffle > /dev/null
option_check -n && mpc next > /dev/null
option_check -b && mpc prev > /dev/null
option_check -p && mpc toggle > /dev/null
option_check -s && mpc stop > /dev/null
option_check -l && mpc playlist
option_check -u && mpc update > /dev/null

