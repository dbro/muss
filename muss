#!/bin/sh
## muss command-line music player interface
# Dan Brown, 2010
# 
# note: interactive mode depends on dmenu with
#       patches for xmms style multiple search
#       and filtermode multiple output.

HELP_MESSAGE="muss version 0.1
usage:   \"muss [options] [[not] <keyword>]...\" 
example: \"muss elvis\"
         \"muss elv pres not jailhouse\"
         \"muss lion rich -a -r\"
         \"muss\" (opens an interactive search menu)
         \"muss -p -l\"
         \"muss -n\"
options:
 -h help (also recognizes -? --help)
 -a append to (don't clear) existing playlist
 -q quiet. disables autoplay for the new playlist
 -r randomize playlist order for the new playlist
 -l list items in current playlist (don't browse)
 -p play/pause current playlist (don't browse)
 -s stop current playlist (don't browse)
 -n next song in current playlist (don't browse)
 -b back to previous song in current playlist (don't browse)
 -u update music database (don't browse)
"

DEBUG=0
PLMARKER="__playlist__ " 

print_debug() {
  # requires 2 arguments: MIN_LEVEL, VARIABLE_NAME
  # NOTE: the \$$ ref/deref requires #!/bin/bash, not #!/bin/sh
  if [ $DEBUG -ge $1 ] 
  then
    echo -n "$2: "; eval echo -n \$$2; echo " ."
  fi
}

PROG_ARGS=" $* "
option_check() {
  # look to see if the user included the option flag in the command
  # requires one argument, the flag. eg "-a"
  echo "$PROG_ARGS" | grep -i -E " $1 " > /dev/null
}

# print help message and usage, then exit
echo " $* " | grep -i -E '[ \t]\-{1,2}(help|h|\?)[ \t]' > /dev/null && \
  echo "$HELP_MESSAGE" && exit

# remember the number of pre-existing playlist items for later removal
PRE_EXISTING_PLAYLIST_COUNT=`mpc playlist | wc -l`

# parse arguments for recognized options
# all non-help (non-early-termination) arguments should be listed below
IGNOREARGS='-a -q -r -l -p -s -n -b -u'
NOBROWSEARGS='-l -p -s -n -b -u'
IGNOREFILTER=" "`echo "$IGNOREARGS" | sed -e 's/ -/ \\\\| -/g'`" "
NOBROWSEFILTER=" "`echo "$NOBROWSEARGS" | sed -e 's/ -/ \\\\| -/g'`" "
SEARCHTERMS=`echo " $* " | sed \
  -e 's/ /  /g' \
  -e "s/$IGNOREFILTER/ /Ig"`
print_debug 1 SEARCHTERMS

if [ `echo $SEARCHTERMS | wc -w` -gt 0 ]
then
  # quicksearch mode
  # use the command line parameters as search terms
  # matching is done by (full) filepath
  # supports the "not" keyword to exclude patterns
  CRITERIA=`echo $SEARCHTERMS | sed \
    -e 's/not \(\S\)/__-v__\1/Ig' \
    -e 's/\S*/| grep -i \"&\"/g' \
    -e 's/\"__-v__/-v \"/g' \
    -e 's/ \"-/ \"\\\\-/g'`
  print_debug 2 CRITERIA
  eval "mpc listall $CRITERIA" | mpc add > /dev/null
  eval "mpc lsplaylists $CRITERIA" | mpc load > /dev/null
elif [ `echo " $* " | grep -i -v "$NOBROWSEFILTER" | wc -l` -gt 0  ]
then
  # interactive browse/search mode
  [ -f $HOME/.dmenurc ] && . $HOME/.dmenurc || DMENU='dmenu'
  DMENU="$DMENU -i -l 10 -f -xs"
  PLAYLISTS_AND_FILES=`mpc lsplaylists | sed -e "s/.*/$PLMARKER&/"`"\\n"`mpc listall`
  print_debug 2 PLAYLISTS_AND_FILES
  ALLMATCHES=`echo "$PLAYLISTS_AND_FILES" | $DMENU`
  print_debug 2 ALLMATCHES
  echo "$ALLMATCHES" | grep -v "$PLMARKER" | mpc add > /dev/null
  echo "$ALLMATCHES" | sed -n -e "s/$PLMARKER//p" | mpc load > /dev/null
fi

# remove pre-existing items if we added items and aren't in append mode
#if [ "$ITEMS_ADDED" -gt 0 ] && ! option_check -a
ADD_COUNT=$(( `mpc playlist | wc -l` - $PRE_EXISTING_PLAYLIST_COUNT ))
if ! option_check -a && [ "$ADD_COUNT" -gt 0 ]
then 
  [ "$PRE_EXISTING_PLAYLIST_COUNT" -gt 0 ] && \
    mpc del "1-$PRE_EXISTING_PLAYLIST_COUNT"
fi

# we need to randomize before autoplay begins
option_check -r && mpc shuffle > /dev/null
option_check -n && mpc next > /dev/null
option_check -b && mpc prev > /dev/null
! option_check -q && [ "$ADD_COUNT" -gt 0 ] && mpc play > /dev/null
option_check -p && mpc toggle > /dev/null
option_check -s && mpc stop > /dev/null
option_check -l && mpc playlist
option_check -u && mpc update > /dev/null

